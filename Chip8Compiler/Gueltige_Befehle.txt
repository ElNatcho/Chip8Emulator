
0x00E0: CLS   ("Clears the screen")
0x00EE: RET   ("Returns from a subroutine")
0x1NNN: JMP   ("Jumps to address NNN")
0x2NNN: CALL  ("Calls subroutine at NNN")
0x3XNN: IE    ("Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)")
0x4XNN: INE   ("Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)")
0x5XY0: IE    ("Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)")
0x6XNN: MOV   ("Sets VX to NN")
0x7XNN: ADD   ("Adds NN to VX")
0x8XY0: MOV   ("Sets VX to the value of VY")
0x8XY1: OR    ("Sets VX to VX or VY. (Bitwise OR operation) VF is reset to 0")
0x8XY2: AND   ("Sets VX to VX and VY. (Bitwise AND operation) VF is reset to 0")
0x8XY3: XOR   ("Sets VX to VX xor VY. VF is reset to 0")
0x8XY4: ADD   ("Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't")
0x8XY5: SUB   ("VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't")
0x8XY6: RSH   ("Shifts VX right by one. VF is set to the value of the least significant bit of VX before the shift")
0x8XY7: SUBC  ("Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't")
0x8XYE: LSH   ("Shifts VX left by one. VF is set to the value of the most significant bit of VX before the shift")
0x9XY0: INE   ("Skips the next instruction if VX doesn't equal VY. (Usually the next instruction is a jump to skip a code block)")
0xANNN: MOV   ("Sets I to the address NNN.")
0xBNNN: JMP0  ("Jumps to the address NNN plus V0")
0xCXNN: RND   ("Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN")
0xDXYN: DRW   ("Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I; I value doesn’t change after the execution of this instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that doesn’t happen")
0xEX9E: IKPR  ("Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)")
0xEXA1: IKNPR ("Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)")
0xFX07: GDT   ("Sets VX to the value of the delay timer")
0xFX0A: WFKPR ("A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)")
0xFX15: SDT   ("Sets the delay timer to VX")
0xFX18: SST   ("Sets the sound timer to VX")
0xFX1E: ADD   ("Adds VX to I")
0xFX29: SISP  ("Sets I to the location of the sprite for the character in VX. Characters 0-F (in hexadecimal) are represented by a 4x5 font")
0xFX33: BCD   ("Stores the binary-coded decimal representation of VX, with the most significant of three digits at the address in I, the middle digit at I plus 1, and the least significant digit at I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.)")
0xFX55: RDMP  ("Stores V0 to VX (including VX) in memory starting at address I")
0xFX65: RLOD  ("Fills V0 to VX (including VX) with values from memory starting at address I")